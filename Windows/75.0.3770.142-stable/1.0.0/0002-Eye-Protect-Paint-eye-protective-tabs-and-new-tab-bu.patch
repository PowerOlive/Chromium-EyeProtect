From 73c7d2d7b34fc894c92396fd9817b5b0182fe5c9 Mon Sep 17 00:00:00 2001
From: FENGberd <fengberd@gmail.com>
Date: Sun, 21 Jul 2019 13:08:22 +0800
Subject: [PATCH 2/5] [Eye Protect] Paint eye protective tabs and new tab
 button

---
 chrome/browser/themes/theme_properties.cc     |  48 ++
 chrome/browser/ui/BUILD.gn                    |   1 +
 chrome/browser/ui/layout_constants.cc         |  20 +
 chrome/browser/ui/tabs/tab_style.cc           |  12 +
 .../browser/ui/views/tabs/new_tab_button.cc   | 212 ++++++
 chrome/browser/ui/views/tabs/new_tab_button.h |   2 +
 chrome/browser/ui/views/tabs/tab.cc           |   8 +-
 chrome/browser/ui/views/tabs/tab_strip.cc     |  52 +-
 chrome/browser/ui/views/tabs/tab_style_ep.cc  | 703 ++++++++++++++++++
 .../browser/ui/views/tabs/tab_style_views.cc  |   9 +
 10 files changed, 1061 insertions(+), 6 deletions(-)
 create mode 100644 chrome/browser/ui/views/tabs/tab_style_ep.cc

diff --git a/chrome/browser/themes/theme_properties.cc b/chrome/browser/themes/theme_properties.cc
index 8529fa6cc223..fbebb565563b 100644
--- a/chrome/browser/themes/theme_properties.cc
+++ b/chrome/browser/themes/theme_properties.cc
@@ -19,6 +19,9 @@
 #include <windows.h>
 #endif
 
+#include "ui/base/material_design/material_design_controller.h"
+using MD = ui::MaterialDesignController;
+
 namespace {
 
 // Strings used in alignment properties.
@@ -181,6 +184,51 @@ color_utils::HSL ThemeProperties::GetDefaultTint(int id, bool incognito) {
 
 // static
 SkColor ThemeProperties::GetDefaultColor(int id, bool incognito) {
+  if (MD::eye_protection()) {
+    // Don't modify GetIncognitoColor,which would make further maintaince harder.
+    switch (id) {
+      case COLOR_FRAME:
+        return incognito ? SkColorSetRGB(0x28, 0x2B, 0x2D)
+                         : SkColorSetRGB(0xCC, 0xCC, 0xCC);
+      case COLOR_FRAME_INACTIVE:
+        return incognito ? SkColorSetRGB(0x38, 0x3B, 0x3D)
+                         : SkColorSetRGB(0xF5, 0xF5, 0xF5);
+
+      case COLOR_BACKGROUND_TAB:
+        return incognito ? SkColorSetRGB(0x50, 0x50, 0x50)
+                         : SkColorSetRGB(0xf2, 0xf2, 0xf2);
+      case COLOR_BACKGROUND_TAB_INACTIVE:
+        return incognito ? SkColorSetRGB(0x37, 0x37, 0x37)
+                         : SkColorSetRGB(0xd0, 0xd0, 0xd0);
+      case COLOR_BACKGROUND_TAB_TEXT:
+      case COLOR_BACKGROUND_TAB_TEXT_INACTIVE:
+        return incognito ? SK_ColorWHITE : SK_ColorBLACK;
+
+      case COLOR_TOOLBAR:
+        return incognito ? SkColorSetRGB(0x50, 0x50, 0x50)
+                         : SkColorSetRGB(0xF2, 0xF2, 0xF2);
+      case COLOR_TAB_TEXT:
+      case COLOR_BOOKMARK_TEXT:
+        return incognito ? SK_ColorWHITE : SK_ColorBLACK;
+
+      case COLOR_NTP_BACKGROUND:
+        return incognito ? SkColorSetRGB(0x32, 0x36, 0x39)
+                         : color_utils::GetSysSkColor(COLOR_WINDOW);
+      case COLOR_TOOLBAR_CONTENT_AREA_SEPARATOR:
+        return incognito ? SkColorSetRGB(0x28, 0x28, 0x28)
+                         : SkColorSetRGB(0xB6, 0xB4, 0xB6);
+      case COLOR_TOOLBAR_TOP_SEPARATOR:
+      case COLOR_TOOLBAR_TOP_SEPARATOR_INACTIVE:
+        return SkColorSetA(SK_ColorBLACK, 0x40);
+      case COLOR_TAB_ALERT_RECORDING:
+        return SkColorSetRGB(0xC5, 0x39, 0x29);
+      case COLOR_TAB_ALERT_CAPTURING:
+        return SkColorSetRGB(0x42, 0x85, 0xF4);
+      default:
+        break;
+    }
+  }
+
   if (incognito) {
     base::Optional<SkColor> incognito_color = GetIncognitoColor(id);
     if (incognito_color.has_value())
diff --git a/chrome/browser/ui/BUILD.gn b/chrome/browser/ui/BUILD.gn
index 7561cab16804..a1d0b737bd84 100644
--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -2970,6 +2970,7 @@ jumbo_split_static_library("ui") {
       "webauthn/transport_hover_list_model.h",
       "webauthn/transport_utils.cc",
       "webauthn/transport_utils.h",
+      "views/tabs/tab_style_ep.cc",
     ]
     deps += [
       "//chrome/browser/ui/views",
diff --git a/chrome/browser/ui/layout_constants.cc b/chrome/browser/ui/layout_constants.cc
index 3b48afcfdf53..018359ee80a0 100644
--- a/chrome/browser/ui/layout_constants.cc
+++ b/chrome/browser/ui/layout_constants.cc
@@ -28,6 +28,26 @@ int GetCocoaLayoutConstant(LayoutConstant constant) {
 
 int GetLayoutConstant(LayoutConstant constant) {
   const bool touch_ui = ui::MaterialDesignController::touch_ui();
+  if (ui::MaterialDesignController::eye_protection()) {
+    // Easier to merge if we write like that
+    switch (constant) {
+      case TAB_ALERT_INDICATOR_CAPTURE_ICON_WIDTH:
+        return 16;
+      case TAB_ALERT_INDICATOR_ICON_WIDTH:
+        return touch_ui ? 12 : 16;
+      case TAB_HEIGHT:
+        return (touch_ui ? 41 : 29) +
+               GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP);
+      case TAB_PRE_TITLE_PADDING:
+        return 6;
+      case TAB_STACK_DISTANCE:
+        return touch_ui ? 4 : 6;
+      case TABSTRIP_TOOLBAR_OVERLAP:
+        return 0;
+      default:
+        break;
+    }
+  }
   switch (constant) {
     case BOOKMARK_BAR_HEIGHT:
       // The fixed margin ensures the bookmark buttons appear centered relative
diff --git a/chrome/browser/ui/tabs/tab_style.cc b/chrome/browser/ui/tabs/tab_style.cc
index 00e4e8ad7481..8c7dadeae659 100644
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -7,6 +7,8 @@
 #include "ui/base/material_design/material_design_controller.h"
 #include "ui/views/layout/layout_provider.h"
 
+using MD = ui::MaterialDesignController;
+
 namespace {
 
 // Thickness in DIPs of the separator painted on the left and right edges of
@@ -24,6 +26,8 @@ TabStyle::~TabStyle() = default;
 
 // static
 int TabStyle::GetStandardWidth() {
+  if (MD::eye_protection())
+    return (MD::touch_ui() ? 245 : 193) + GetContentsHorizontalInsetSize();
   // The standard tab width is 240 DIP including both separators.
   constexpr int kTabWidth = 240;
   // The overlap includes one separator, so subtract it here.
@@ -38,6 +42,8 @@ int TabStyle::GetPinnedWidth() {
 
 // static
 int TabStyle::GetTabOverlap() {
+  if (MD::eye_protection())
+    return MD::touch_ui() ? 24 : 16;
   return GetCornerRadius() * 2 + kSeparatorThickness;
 }
 
@@ -48,11 +54,15 @@ int TabStyle::GetDragHandleExtension(int height) {
 
 // static
 gfx::Insets TabStyle::GetTabInternalPadding() {
+  if (MD::eye_protection())
+    return gfx::Insets(0, 16);
   return gfx::Insets(0, GetCornerRadius());
 }
 
 // static
 gfx::Size TabStyle::GetSeparatorSize() {
+  if (MD::eye_protection())
+    return gfx::Size(0, GetSeparatorHeight());
   return gfx::Size(kSeparatorThickness, GetSeparatorHeight());
 }
 
@@ -71,5 +81,7 @@ int TabStyle::GetCornerRadius() {
 
 // static
 int TabStyle::GetContentsHorizontalInsetSize() {
+  if (MD::eye_protection())
+    return MD::touch_ui() ? 24 : 16;
   return GetCornerRadius() * 2;
 }
diff --git a/chrome/browser/ui/views/tabs/new_tab_button.cc b/chrome/browser/ui/views/tabs/new_tab_button.cc
index 480a20f29acb..3d0d16f61d1a 100644
--- a/chrome/browser/ui/views/tabs/new_tab_button.cc
+++ b/chrome/browser/ui/views/tabs/new_tab_button.cc
@@ -29,6 +29,200 @@
 #include "ui/views/view_class_properties.h"
 #include "ui/views/widget/widget.h"
 
+#include "third_party/skia/include/core/SkColorFilter.h"
+#include "third_party/skia/include/core/SkMaskFilter.h"
+#include "third_party/skia/include/effects/SkLayerDrawLooper.h"
+#include "third_party/skia/include/pathops/SkPathOps.h"
+#include "ui/gfx/color_palette.h"
+#include "ui/gfx/paint_vector_icon.h"
+
+using MD = ui::MaterialDesignController;
+
+namespace eye_protection {
+sk_sp<SkDrawLooper> CreateShadowDrawLooper(SkColor color) {
+  SkLayerDrawLooper::Builder looper_builder;
+  looper_builder.addLayer();
+
+  SkLayerDrawLooper::LayerInfo layer_info;
+  layer_info.fPaintBits |= SkLayerDrawLooper::kMaskFilter_Bit;
+  layer_info.fPaintBits |= SkLayerDrawLooper::kColorFilter_Bit;
+  layer_info.fColorMode = SkBlendMode::kDst;
+  layer_info.fOffset.set(0, 1);
+  SkPaint* layer_paint = looper_builder.addLayer(layer_info);
+  layer_paint->setMaskFilter(SkMaskFilter::MakeBlur(kNormal_SkBlurStyle, 0.5));
+  layer_paint->setColorFilter(
+      SkColorFilters::Blend(color, SkBlendMode::kSrcIn));
+  return looper_builder.detach();
+}
+
+SkPath GetButtonPathEP(int button_y,
+                       int button_height,
+                       int button_width,
+                       float scale,
+                       bool extend_to_top,
+                       bool for_fill) {
+  const float inverse_slope =
+      (MD::touch_ui() ? 19.5f : 11.5f) / (GetLayoutConstant(TAB_HEIGHT) - 4);
+  float bottom = (button_height - 2) * scale;
+  const float diag_height = bottom - 3.5 * scale;
+  const float diag_width = diag_height * inverse_slope;
+  const float right = diag_width + 4 * scale;
+  const int stroke_thickness = for_fill ? 0 : 1;
+  bottom += button_y + stroke_thickness;
+
+  SkPath path;
+  path.moveTo(right - stroke_thickness, bottom);
+  path.rCubicTo(-0.75 * scale, 0, -1.625 * scale, -0.5 * scale, -2 * scale,
+                -1.5 * scale);
+  path.rLineTo(-diag_width, -diag_height);
+  if (extend_to_top) {
+    // Create the vertical extension by extending the side diagonals at the
+    // upper left and lower right corners until they reach the top and bottom of
+    // the border, respectively (in other words, "un-round-off" those corners
+    // and turn them into sharp points).  Then extend upward from the corner
+    // points to the top of the bounds.
+    const float dy = scale + stroke_thickness * 2;
+    const float dx = inverse_slope * dy;
+    path.rLineTo(-dx, -dy);
+    path.rLineTo(0, -button_y - scale + stroke_thickness);
+    path.lineTo((button_width - 2) * scale + stroke_thickness + dx, 0);
+    path.rLineTo(0, bottom);
+  } else {
+    if (for_fill) {
+      path.rCubicTo(0, -0.5 * scale, 0.25 * scale, -scale, scale, -scale);
+    } else {
+      path.rCubicTo(-0.5 * scale, -1.125 * scale, 0.5 * scale,
+                    -scale - 2 * stroke_thickness, scale,
+                    -scale - 2 * stroke_thickness);
+    }
+    path.lineTo((button_width - 4) * scale - diag_width + stroke_thickness,
+                button_y + scale - stroke_thickness);
+    path.rCubicTo(0.75 * scale, 0, 1.625 * scale, 0.5 * scale, 2 * scale,
+                  1.5 * scale);
+    path.rLineTo(diag_width, diag_height);
+    if (for_fill) {
+      path.rCubicTo(0, 0.5 * scale, -0.25 * scale, scale, -scale, scale);
+    } else {
+      path.rCubicTo(0.5 * scale, 1.125 * scale, -0.5 * scale,
+                    scale + 2 * stroke_thickness, -scale,
+                    scale + 2 * stroke_thickness);
+    }
+  }
+  path.close();
+
+  return path;
+}
+}  // namespace eye_protection
+
+void NewTabButton::PaintButtonContentsEP(gfx::Canvas* canvas) {
+  gfx::ScopedCanvas scoped_canvas(canvas);
+  const gfx::Rect contents_bounds = GetContentsBounds();
+  canvas->Translate(contents_bounds.OffsetFromOrigin());
+  const float scale = canvas->image_scale();
+  const bool pressed = state() == views::Button::STATE_PRESSED;
+  const SkColor stroke_color =
+      new_tab_promo_observer_.IsObservingSources()
+          ? color_utils::AlphaBlend(
+                SK_ColorBLACK,
+                GetNativeTheme()->GetSystemColor(
+                    ui::NativeTheme::kColorId_ProminentButtonColor),
+                (SkAlpha)0x70)
+          : tab_strip_->GetToolbarTopSeparatorColor();
+  int height = contents_bounds.height(), width = contents_bounds.width();
+
+  SkPath fill = eye_protection::GetButtonPathEP(0, height, width, scale, false,
+                                                true),
+         stroke = eye_protection::GetButtonPathEP(0, height, width, scale,
+                                                  false, false);
+
+  // Paint Fill
+  {
+    canvas->UndoDeviceScaleFactor();
+    cc::PaintFlags flags;
+    flags.setAntiAlias(true);
+    // For unpressed buttons, draw the fill and its shadow.
+    // Note that for newer UI, we always draw the fill since the button
+    // has a flat design. Hover highlights are handled by the ink drop.
+    if (!pressed) {
+      // First we compute the background image coordinates and scale, in case
+      // we need to draw a custom background image.
+      const ui::ThemeProvider* tp = GetThemeProvider();
+      bool has_custom_image;
+      const int bg_id = tab_strip_->GetBackgroundResourceId(&has_custom_image);
+      if (has_custom_image && !new_tab_promo_observer_.IsObservingSources()) {
+        // For non-refresh touch UI, the background is that of the active tab,
+        // so the positioning must match that in Tab::PaintTab().
+        const int offset_y = 0;
+        // The new tab background is mirrored in RTL mode, but the theme
+        // background should never be mirrored. Mirror it here to compensate.
+        float x_scale = 1.0f;
+        int x = GetMirroredX() + contents_bounds.x() + background_offset_;
+        if (base::i18n::IsRTL()) {
+          x_scale = -1.0f;
+          // Offset by |width| such that the same region is painted as if
+          // there was no flip.
+          x += contents_bounds.width();
+        }
+        const bool succeeded = canvas->InitPaintFlagsForTiling(
+            *tp->GetImageSkiaNamed(bg_id), x, contents_bounds.y() + offset_y,
+            x_scale * scale, scale, 0, 0, SkTileMode::kRepeat,
+            SkTileMode::kRepeat, &flags);
+        DCHECK(succeeded);
+      } else {
+        flags.setColor(GetButtonFillColor());
+      }
+
+      cc::PaintFlags shadow_flags = flags;
+      const SkColor stroke_color = tab_strip_->GetToolbarTopSeparatorColor();
+      const SkAlpha alpha = static_cast<SkAlpha>(
+          std::round(SkColorGetA(stroke_color) * 0.59375f));
+      shadow_flags.setLooper(eye_protection::CreateShadowDrawLooper(
+          SkColorSetA(stroke_color, alpha)));
+      canvas->DrawPath(fill, shadow_flags);
+    }
+
+    // Draw a white highlight on hover.
+    const SkAlpha hover_alpha =
+        static_cast<SkAlpha>(hover_animation().CurrentValueBetween(0x00, 0x4D));
+    if (hover_alpha != SK_AlphaTRANSPARENT) {
+      flags.setColor(SkColorSetA(SK_ColorWHITE, hover_alpha));
+      canvas->DrawPath(fill, flags);
+    }
+
+    // Most states' opacities are adjusted using an opacity recorder in
+    // TabStrip::PaintChildren(), but the pressed state is excluded there and
+    // instead rendered using a dark overlay here.  Avoiding the use of the
+    // opacity recorder keeps the stroke more visible in this state.
+    if (pressed) {
+      flags.setColor(GetButtonFillColor());
+      canvas->DrawPath(fill, flags);
+    }
+  }
+
+  // Paint Stroke
+  {
+    canvas->UndoDeviceScaleFactor();
+    if (pressed)
+      canvas->ClipPath(stroke, true);
+    Op(stroke, fill, kDifference_SkPathOp, &stroke);
+    if (!pressed)
+      canvas->sk_canvas()->clipPath(fill, SkClipOp::kDifference, true);
+    // Now draw the stroke and shadow; the stroke will always be visible,
+    // while the shadow will be affected by the clip we set above.
+    cc::PaintFlags flags;
+    flags.setAntiAlias(true);
+    const float alpha = SkColorGetA(stroke_color);
+    const SkAlpha shadow_alpha =
+        base::saturated_cast<SkAlpha>(std::round(2.1875f * alpha));
+    flags.setLooper(eye_protection::CreateShadowDrawLooper(
+        SkColorSetA(stroke_color, shadow_alpha)));
+    const SkAlpha path_alpha = static_cast<SkAlpha>(
+        std::round((pressed ? 0.875f : 0.609375f) * alpha));
+    flags.setColor(SkColorSetA(stroke_color, path_alpha));
+    canvas->DrawPath(stroke, flags);
+  }
+}
+
 #if defined(OS_WIN)
 #include "ui/display/win/screen_win.h"
 #include "ui/gfx/win/hwnd_util.h"
@@ -75,6 +269,10 @@ NewTabButton::NewTabButton(TabStrip* tab_strip, views::ButtonListener* listener)
   set_ink_drop_highlight_opacity(0.1f);
 
   SetInstallFocusRingOnFocus(true);
+
+  if (MD::eye_protection()) {
+    SetInkDropMode(InkDropMode::OFF);
+  }
 }
 
 NewTabButton::~NewTabButton() {
@@ -152,6 +350,10 @@ void NewTabButton::NotifyClick(const ui::Event& event) {
 }
 
 void NewTabButton::PaintButtonContents(gfx::Canvas* canvas) {
+  if (MD::eye_protection()) {
+    PaintButtonContentsEP(canvas);
+    return;
+  }
   gfx::ScopedCanvas scoped_canvas(canvas);
   canvas->Translate(GetContentsBounds().OffsetFromOrigin());
   PaintFill(canvas);
@@ -167,6 +369,9 @@ void NewTabButton::OnBoundsChanged(const gfx::Rect& previous_bounds) {
 
 gfx::Size NewTabButton::CalculatePreferredSize() const {
   gfx::Size size = kButtonSize;
+  if (MD::eye_protection()) {
+    size = {36, 18};
+  }
   const auto insets = GetInsets();
   size.Enlarge(insets.width(), insets.height());
   return size;
@@ -179,6 +384,8 @@ bool NewTabButton::GetHitTestMask(SkPath* mask) const {
   // TODO(pkasting): Fitts' Law horizontally when appropriate.
   SkPath border = GetBorderPath(GetContentsBounds().origin(), scale,
                                 tab_strip_->controller()->IsFrameCondensed());
+  if (MD::eye_protection())
+    border.offset(GetContentsBounds().origin().x(), 0);
   mask->addPath(border, SkMatrix::MakeScale(1 / scale));
   return true;
 }
@@ -274,6 +481,11 @@ SkColor NewTabButton::GetButtonFillColor() const {
 SkPath NewTabButton::GetBorderPath(const gfx::Point& origin,
                                    float scale,
                                    bool extend_to_top) const {
+  if (MD::eye_protection()) {
+    return eye_protection::GetButtonPathEP(
+        origin.y() * scale, GetContentsBounds().height(),
+        GetContentsBounds().width(), scale, extend_to_top, false);
+  }
   gfx::PointF scaled_origin(origin);
   scaled_origin.Scale(scale);
   const float radius = GetCornerRadius() * scale;
diff --git a/chrome/browser/ui/views/tabs/new_tab_button.h b/chrome/browser/ui/views/tabs/new_tab_button.h
index 344125c7e95a..9508659270c0 100644
--- a/chrome/browser/ui/views/tabs/new_tab_button.h
+++ b/chrome/browser/ui/views/tabs/new_tab_button.h
@@ -112,6 +112,8 @@ class NewTabButton : public views::ImageButton,
   // open and get called back when it closes.
   ScopedObserver<views::Widget, WidgetObserver> new_tab_promo_observer_{this};
 
+  void PaintButtonContentsEP(gfx::Canvas* canvas);
+
   DISALLOW_COPY_AND_ASSIGN(NewTabButton);
 };
 
diff --git a/chrome/browser/ui/views/tabs/tab.cc b/chrome/browser/ui/views/tabs/tab.cc
index 70a383159a9b..90138ccb988a 100644
--- a/chrome/browser/ui/views/tabs/tab.cc
+++ b/chrome/browser/ui/views/tabs/tab.cc
@@ -225,7 +225,8 @@ void Tab::Layout() {
   int start = contents_rect.x();
   if (extra_padding_before_content_) {
     constexpr int kExtraLeftPaddingToBalanceCloseButtonPadding = 4;
-    start += kExtraLeftPaddingToBalanceCloseButtonPadding;
+    start +=
+        MD::eye_protection() ? 2 : kExtraLeftPaddingToBalanceCloseButtonPadding;
   }
 
   // The bounds for the favicon will include extra width for the attention
@@ -581,6 +582,11 @@ void Tab::PaintChildren(const views::PaintInfo& info) {
 }
 
 void Tab::OnPaint(gfx::Canvas* canvas) {
+  // Don't paint if we're narrower than we can render correctly. (This should
+  // only happen during animations).
+  if (MD::eye_protection() && width() < 16)
+    return;
+
   SkPath clip;
   if (!controller_->ShouldPaintTab(this, canvas->image_scale(), &clip))
     return;
diff --git a/chrome/browser/ui/views/tabs/tab_strip.cc b/chrome/browser/ui/views/tabs/tab_strip.cc
index 9c3776f24307..39ed74c8fc03 100644
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -56,6 +56,7 @@
 #include "ui/base/material_design/material_design_controller.h"
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/resource/resource_bundle.h"
+#include "ui/compositor/paint_recorder.h"
 #include "ui/display/display.h"
 #include "ui/display/screen.h"
 #include "ui/gfx/animation/throb_animation.h"
@@ -737,6 +738,10 @@ bool TabStrip::ShouldDrawStrokes() const {
   if (!controller_->CanDrawStrokes())
     return false;
 
+  // Just draw it if user want to protect his/her eyes
+  if (MD::eye_protection())
+    return true;
+
   // The tabstrip normally avoids strokes and relies on the active tab
   // contrasting sufficiently with the frame background.  When there isn't
   // enough contrast, fall back to a stroke.  Always compute the contrast ratio
@@ -1273,14 +1278,14 @@ SkColor TabStrip::GetTabBackgroundColor(
   else
     is_active_frame = active_state == BrowserNonClientFrameView::kActive;
 
-  const int color_id = is_active_frame
+  const int color_id = (!MD::eye_protection() && is_active_frame)
                            ? ThemeProperties::COLOR_BACKGROUND_TAB
                            : ThemeProperties::COLOR_BACKGROUND_TAB_INACTIVE;
   // When the background tab color has not been customized, use the actual frame
   // color instead of COLOR_BACKGROUND_TAB.
   const SkColor frame = controller_->GetFrameColor(active_state);
   const SkColor background =
-      tp->HasCustomColor(color_id)
+      (MD::eye_protection() || tp->HasCustomColor(color_id))
           ? tp->GetColor(color_id)
           : color_utils::HSLShift(
                 frame, tp->GetTint(ThemeProperties::TINT_BACKGROUND_TAB));
@@ -1422,7 +1427,7 @@ void TabStrip::PaintChildren(const views::PaintInfo& paint_info) {
   // this code defers drawing such tabs until later.
   const auto paint_or_add_to_tabs = [&paint_info,
                                      &selected_and_hovered_tabs](Tab* tab) {
-    if (tab->tab_style()->GetZValue() > 0.0) {
+    if (!MD::eye_protection() && tab->tab_style()->GetZValue() > 0.0) {
       selected_and_hovered_tabs.push_back(tab);
     } else {
       tab->Paint(paint_info);
@@ -1494,6 +1499,32 @@ void TabStrip::PaintChildren(const views::PaintInfo& paint_info) {
   // If the active tab is being dragged, it goes last.
   if (active_tab && is_dragging)
     active_tab->Paint(paint_info);
+
+  if (MD::eye_protection()) {
+    ui::PaintRecorder recorder(paint_info.context(),
+                               paint_info.paint_recording_size(),
+                               paint_info.paint_recording_scale_x(),
+                               paint_info.paint_recording_scale_y(), nullptr);
+    gfx::Canvas* canvas = recorder.canvas();
+    if (active_tab && active_tab->visible()) {
+      canvas->sk_canvas()->clipRect(
+          gfx::RectToSkRect(active_tab->GetMirroredBounds()),
+          SkClipOp::kDifference);
+    }
+    // Paint Toolbar Top Separator
+    const gfx::Rect& bounds = GetLocalBounds();
+    const float thickness = 1 / canvas->image_scale();
+    cc::PaintFlags flags;
+    flags.setColor(GetToolbarTopSeparatorColor());
+    flags.setStyle(cc::PaintFlags::kFill_Style);
+    canvas->sk_canvas()->drawRect(
+        RectFToSkRect(gfx::RectF(
+            bounds.x(),
+            bounds.bottom() - GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP) -
+                thickness,
+            bounds.width(), thickness)),
+        flags);
+  }
 }
 
 const char* TabStrip::GetClassName() const {
@@ -1720,6 +1751,9 @@ bool TabStrip::ShouldHighlightCloseButtonAfterRemove() {
 }
 
 int TabStrip::TabToNewTabButtonSpacing() const {
+  if (MD::eye_protection()) {
+    return MD::touch_ui() ? 6: -5;
+  }
   // The new tab button contains built-in padding, and should be placed flush
   // against the trailing separator.
   return -TabStyle::GetTabInternalPadding().right();
@@ -2617,8 +2651,16 @@ void TabStrip::SetResetToShrinkOnExit(bool value) {
     RemoveMessageLoopObserver();
 }
 
-void TabStrip::UpdateNewTabButtonBorder() {
-  // The button is placed vertically exactly in the center of the tabstrip.
+  void TabStrip::UpdateNewTabButtonBorder() {
+    if (MD::eye_protection()) {
+      const int extra_vertical_space =
+          GetLayoutConstant(TAB_HEIGHT) -
+          GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP) - 18;
+      new_tab_button_->SetBorder(views::CreateEmptyBorder(
+          gfx::Insets(extra_vertical_space - 4, 0, 0, 0)));
+      return;
+    }
+ // The button is placed vertically exactly in the center of the tabstrip.
   const int extra_vertical_space = GetLayoutConstant(TAB_HEIGHT) -
                                    GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP) -
                                    NewTabButton::kButtonSize.height();
diff --git a/chrome/browser/ui/views/tabs/tab_style_ep.cc b/chrome/browser/ui/views/tabs/tab_style_ep.cc
new file mode 100644
index 000000000000..c030324de826
--- /dev/null
+++ b/chrome/browser/ui/views/tabs/tab_style_ep.cc
@@ -0,0 +1,703 @@
+#include "chrome/browser/ui/views/tabs/tab_style_views.h"
+
+#include <algorithm>
+#include <utility>
+
+#include "base/numerics/ranges.h"
+#include "cc/paint/paint_record.h"
+#include "chrome/browser/themes/theme_properties.h"
+#include "chrome/browser/ui/layout_constants.h"
+#include "chrome/browser/ui/views/tabs/glow_hover_controller.h"
+#include "chrome/browser/ui/views/tabs/tab.h"
+#include "chrome/browser/ui/views/tabs/tab_close_button.h"
+#include "chrome/browser/ui/views/tabs/tab_controller.h"
+#include "chrome/grit/theme_resources.h"
+#include "third_party/skia/include/core/SkScalar.h"
+#include "third_party/skia/include/pathops/SkPathOps.h"
+#include "ui/base/theme_provider.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/scoped_canvas.h"
+#include "ui/views/style/platform_style.h"
+#include "ui/views/widget/widget.h"
+
+#include "ui/base/material_design/material_design_controller.h"
+
+using MD = ui::MaterialDesignController;
+
+namespace eye_protection {
+constexpr float kSelectedTabOpacity = 0.75f;
+
+// Helpers -------------------------------------------------------------
+
+float GetInverseDiagonalSlope() {
+  return (MD::touch_ui() ? 19.5f : 11.5f) / (GetLayoutConstant(TAB_HEIGHT) - 4);
+}
+
+SkPath OffsetAndIntersectPaths(SkPath& left_path,
+                               SkPath& right_path,
+                               const gfx::InsetsF& insets) {
+  // This code is not prepared to deal with vertical adjustments.
+  DCHECK_EQ(0, insets.top());
+  DCHECK_EQ(0, insets.bottom());
+
+  SkPath complete_path;
+  left_path.offset(insets.left(), 0);
+  right_path.offset(-insets.right(), 0);
+  Op(left_path, right_path, SkPathOp::kIntersect_SkPathOp, &complete_path);
+  return complete_path;
+}
+
+// Returns a path corresponding to the tab's outer border for a given tab
+// |scale| and |bounds|.  If |unscale_at_end| is true, this path will be
+// normalized to a 1x scale by scaling by 1/scale before returning.  If
+// |extend_to_top| is true, the path is extended vertically to the top of the
+// tab bounds.  The caller uses this for Fitts' Law purposes in
+// maximized/fullscreen mode.
+SkPath GetBorderPath(float scale,
+                     float stroke_thickness,
+                     bool unscale_at_end,
+                     bool extend_to_top,
+                     const gfx::Rect& bounds) {
+  SkPath path;
+  const float top = scale - stroke_thickness;
+  const float right = bounds.width() * scale;
+  const float bottom = bounds.height() * scale;
+  const float endcap_width = MD::touch_ui() ? 23.5f : 15.5f;
+  path.moveTo(0, bottom);
+  path.rLineTo(0, -stroke_thickness);
+  path.rCubicTo(0.75 * scale, 0, 1.625 * scale, -0.5 * scale, 2 * scale,
+                -1.5 * scale);
+  path.lineTo((endcap_width - 2) * scale, top + 1.5 * scale);
+  if (extend_to_top) {
+    // Create the vertical extension by extending the side diagonals until
+    // they reach the top of the bounds.
+    const float dy = 2.5 * scale - stroke_thickness;
+    const float dx =
+        GetInverseDiagonalSlope() / (GetLayoutConstant(TAB_HEIGHT) - 4) * dy;
+    path.rLineTo(dx, -dy);
+    path.lineTo(right - (endcap_width - 2) * scale - dx, 0);
+    path.rLineTo(dx, dy);
+  } else {
+    path.rCubicTo(0.375 * scale, -scale, 1.25 * scale, -1.5 * scale, 2 * scale,
+                  -1.5 * scale);
+    path.lineTo(right - endcap_width * scale, top);
+    path.rCubicTo(0.75 * scale, 0, 1.625 * scale, 0.5 * scale, 2 * scale,
+                  1.5 * scale);
+  }
+  path.lineTo(right - 2 * scale, bottom - stroke_thickness - 1.5 * scale);
+  path.rCubicTo(0.375 * scale, scale, 1.25 * scale, 1.5 * scale, 2 * scale,
+                1.5 * scale);
+  path.rLineTo(0, stroke_thickness);
+  path.close();
+
+  if (unscale_at_end && (scale != 1))
+    path.transform(SkMatrix::MakeScale(1.f / scale));
+
+  return path;
+}
+
+void DrawHighlight(gfx::Canvas* canvas,
+                   const SkPoint& p,
+                   SkScalar radius,
+                   SkColor color) {
+  const SkColor colors[2] = {color, SkColorSetA(color, 0)};
+  cc::PaintFlags flags;
+  flags.setAntiAlias(true);
+  flags.setShader(cc::PaintShader::MakeRadialGradient(
+      p, radius, colors, nullptr, 2, SkTileMode::kClamp));
+  canvas->sk_canvas()->drawRect(
+      SkRect::MakeXYWH(p.x() - radius, p.y() - radius, radius * 2, radius * 2),
+      flags);
+}
+
+// BackgroundCache -------------------------------------------------------------
+
+// Updates a target value, returning true if it changed.
+template <class T>
+bool UpdateValue(T* dest, const T& src) {
+  if (*dest == src)
+    return false;
+  *dest = src;
+  return true;
+}
+
+// Cache of pre-painted backgrounds for tabs.
+class BackgroundCache {
+ public:
+  BackgroundCache() = default;
+  ~BackgroundCache() = default;
+
+  // Updates the cache key with the new values.
+  // Returns true if any of the values changed.
+  bool UpdateCacheKey(float scale,
+                      const gfx::Size& size,
+                      SkColor active_color,
+                      SkColor inactive_color,
+                      SkColor stroke_color,
+                      float stroke_thickness);
+
+  const sk_sp<cc::PaintRecord>& fill_record() const { return fill_record_; }
+  void set_fill_record(sk_sp<cc::PaintRecord>&& record) {
+    fill_record_ = record;
+  }
+
+  const sk_sp<cc::PaintRecord>& stroke_record() const { return stroke_record_; }
+  void set_stroke_record(sk_sp<cc::PaintRecord>&& record) {
+    stroke_record_ = record;
+  }
+
+ private:
+  // Parameters used to construct the PaintRecords.
+  float scale_ = 0.f;
+  gfx::Size size_;
+  SkColor active_color_ = 0;
+  SkColor inactive_color_ = 0;
+  SkColor stroke_color_ = 0;
+  float stroke_thickness_ = 0.f;
+
+  sk_sp<cc::PaintRecord> fill_record_;
+  sk_sp<cc::PaintRecord> stroke_record_;
+
+  DISALLOW_COPY_AND_ASSIGN(BackgroundCache);
+};
+
+bool BackgroundCache::UpdateCacheKey(float scale,
+                                     const gfx::Size& size,
+                                     SkColor active_color,
+                                     SkColor inactive_color,
+                                     SkColor stroke_color,
+                                     float stroke_thickness) {
+  // Use | instead of || to prevent lazy evaluation.
+  return UpdateValue(&scale_, scale) | UpdateValue(&size_, size) |
+         UpdateValue(&active_color_, active_color) |
+         UpdateValue(&inactive_color_, inactive_color) |
+         UpdateValue(&stroke_color_, stroke_color) |
+         UpdateValue(&stroke_thickness_, stroke_thickness);
+}
+
+// EPTabStyle -------------------------------------------------------------
+
+class EPTabStyle : public TabStyleViews {
+ public:
+  explicit EPTabStyle(Tab* tab);
+
+ protected:
+  // TabStyle:
+  SkPath GetPath(
+      PathType path_type,
+      float scale,
+      bool force_active = false,
+      RenderUnits render_units = RenderUnits::kPixels) const override;
+  gfx::Insets GetContentsInsets() const override;
+  float GetZValue() const override;
+  TabStyle::TabColors CalculateColors() const override;
+  void PaintTab(gfx::Canvas* canvas, const SkPath& clip) const override;
+  void SetHoverLocation(const gfx::Point& location) override;
+  void ShowHover(ShowHoverStyle style) override;
+  void HideHover(HideHoverStyle style) override;
+
+ private:
+  // Returns whether the hover animation is being shown.
+  bool IsHoverActive() const;
+
+  // Returns the progress (0 to 1) of the hover animation.
+  double GetHoverAnimationValue() const;
+
+  // Returns the opacity of the hover effect that should be drawn, which may not
+  // be the same as GetHoverAnimationValue.
+  float GetHoverOpacity() const;
+
+  // Gets the throb value. A value of 0 indicates no throbbing.
+  float GetThrobValue() const;
+
+  // Returns the thickness of the stroke drawn around the top and sides of the
+  // tab. Only active tabs may have a stroke, and not in all cases. If there
+  // is no stroke, returns 0. If |should_paint_as_active| is true, the tab is
+  // treated as an active tab regardless of its true current state.
+  int GetStrokeThickness(bool should_paint_as_active = false) const;
+
+  // Painting helper functions:
+  void PaintInactiveTabBackground(gfx::Canvas* canvas,
+                                  const SkPath& clip) const;
+  void PaintTabBackground(gfx::Canvas* canvas,
+                          bool active,
+                          int fill_id,
+                          int y_inset,
+                          const SkPath* clip) const;
+  void PaintTabBackgroundFill(gfx::Canvas* canvas,
+                              const SkPath& fill_path,
+                              bool active,
+                              bool paint_hover_effect,
+                              SkColor active_color,
+                              SkColor inactive_color,
+                              int fill_id,
+                              int y_inset) const;
+  void PaintTabBackgroundStroke(gfx::Canvas* canvas,
+                                const SkPath& fill_path,
+                                const SkPath& stroke_path,
+                                bool active,
+                                SkColor stroke_color) const;
+
+  // Given a tab of width |width|, returns the radius to use for the corners.
+  static float GetTopCornerRadiusForWidth(int width);
+
+  const Tab* const tab_;
+
+  std::unique_ptr<GlowHoverController> hover_controller_;
+
+  // Cache of the paint output for tab backgrounds.
+  mutable BackgroundCache background_active_cache_;
+  mutable BackgroundCache background_inactive_cache_;
+
+  DISALLOW_COPY_AND_ASSIGN(EPTabStyle);
+};
+
+EPTabStyle::EPTabStyle(Tab* tab)
+    : tab_(tab),
+      hover_controller_(gfx::Animation::ShouldRenderRichAnimation()
+                            ? new GlowHoverController(tab)
+                            : nullptr) {}
+
+SkPath EPTabStyle::GetPath(PathType path_type,
+                           float scale,
+                           bool force_active,
+                           RenderUnits render_units) const {
+  const int stroke_thickness = GetStrokeThickness();
+  const gfx::Rect& bounds = tab_->bounds();
+  SkPath path;
+  switch (path_type) {
+    case PathType::kBorder: {
+      path = GetBorderPath(scale, stroke_thickness, false, false, bounds);
+      break;
+    }
+    case PathType::kHitTest: {
+      // When the window is maximized we don't want to shave off the edges or
+      // top
+      // shadow of the tab, such that the user can click anywhere along the top
+      // edge of the screen to select a tab. Ditto for immersive fullscreen.
+      const views::Widget* widget = tab_->GetWidget();
+      path = GetBorderPath(
+          widget->GetCompositor()->device_scale_factor(), stroke_thickness,
+          true, widget && (widget->IsMaximized() || widget->IsFullscreen()),
+          bounds);
+      break;
+    }
+    case PathType::kExteriorClip: {
+      path = GetBorderPath(scale, stroke_thickness, true, false, bounds);
+      break;
+    }
+    case PathType::kFill:
+    case PathType::kInteriorClip: {
+      // Returns a path corresponding to the tab's content region inside the
+      // outer stroke. The sides of the path will be inset by |insets|; this
+      // is useful when trying to clip favicons to match the overall tab shape
+      // but be inset from the edge.
+
+      const float right = bounds.width() * scale;
+      // The bottom of the tab needs to be pixel-aligned or else when we call
+      // ClipPath with anti-aliasing enabled it can cause artifacts.
+      const float bottom = std::ceil(bounds.height() * scale);
+      const float endcap_width = MD::touch_ui() ? 23.5f : 15.5f;
+
+      // Construct the interior path by intersecting paths representing the
+      // left and right halves of the tab.  Compared to computing the full
+      // path at once, this makes it easier to avoid overdraw in the top
+      // center near minimum width, and to implement cases where
+      // !insets.IsEmpty().
+
+      SkPath right_path;
+      right_path.moveTo(right - 1, bottom);
+      right_path.rCubicTo(-0.75 * scale, 0, -1.625 * scale, -0.5 * scale,
+                          -2 * scale, -1.5 * scale);
+      right_path.lineTo(right - 1 - (endcap_width - 2) * scale, 2.5 * scale);
+      right_path.rCubicTo(-0.375 * scale, -1 * scale, -1.25 * scale,
+                          -1.5 * scale, -2 * scale, -1.5 * scale);
+      right_path.lineTo(0, scale);
+      right_path.lineTo(0, bottom);
+      right_path.close();
+
+      SkPath left_path;
+      left_path.moveTo(1 + endcap_width * scale, scale);
+      left_path.rCubicTo(-0.75 * scale, 0, -1.625 * scale, 0.5 * scale,
+                         -2 * scale, 1.5 * scale);
+      left_path.lineTo(1 + 2 * scale, bottom - 1.5 * scale);
+      left_path.rCubicTo(-0.375 * scale, scale, -1.25 * scale, 1.5 * scale,
+                         -2 * scale, 1.5 * scale);
+      left_path.lineTo(right, bottom);
+      left_path.lineTo(right, scale);
+      left_path.close();
+      path = OffsetAndIntersectPaths(left_path, right_path,
+                                     gfx::InsetsF().Scale(scale));
+      break;
+    }
+    case PathType::kHighlight: {
+      path.addRect(bounds.x(), bounds.y(), bounds.right(), bounds.bottom());
+      gfx::PointF origin(tab_->origin());
+      origin.Scale(scale);
+      path.offset(-origin.x(), -origin.y());
+      if (render_units == RenderUnits::kDips && scale != 1.0f)
+        path.transform(SkMatrix::MakeScale(1.f / scale));
+      break;
+    }
+  }
+  return path;
+}
+
+gfx::Insets EPTabStyle::GetContentsInsets() const {
+  const int stroke_thickness = GetStrokeThickness();
+  const int horizontal_inset = GetContentsHorizontalInsetSize();
+  return gfx::Insets(
+      stroke_thickness, horizontal_inset,
+      stroke_thickness + GetLayoutConstant(TABSTRIP_TOOLBAR_OVERLAP),
+      horizontal_inset);
+}
+
+float EPTabStyle::GetZValue() const {
+  // This will return values so that inactive tabs can be sorted in the
+  // following order:
+  //
+  // o Unselected tabs, in ascending hover animation value order.
+  // o The single unselected tab being hovered by the mouse, if present.
+  // o Selected tabs, in ascending hover animation value order.
+  // o The single selected tab being hovered by the mouse, if present.
+  //
+  // Representing the above groupings is accomplished by adding a "weight" to
+  // the current hover animation value.
+  //
+  // 0.0 == z-value         Unselected/non hover animating.
+  // 0.0 <  z-value <= 1.0  Unselected/hover animating.
+  // 2.0 <= z-value <= 3.0  Unselected/mouse hovered tab.
+  // 4.0 == z-value         Selected/non hover animating.
+  // 4.0 <  z-value <= 5.0  Selected/hover animating.
+  // 6.0 <= z-value <= 7.0  Selected/mouse hovered tab.
+  //
+  // This function doesn't handle active tabs, as they are normally painted by a
+  // different code path (with z-value infinity).
+  float sort_value = GetHoverAnimationValue();
+  if (tab_->IsSelected())
+    sort_value += 4.f;
+  if (tab_->mouse_hovered())
+    sort_value += 2.f;
+  return sort_value;
+}
+
+TabStyle::TabColors EPTabStyle::CalculateColors() const {
+  const ui::ThemeProvider* theme_provider = tab_->GetThemeProvider();
+
+  // These ratios are calculated from the default Chrome theme colors.
+  // Active/inactive are the contrast ratios of the close X against the tab
+  // background. Hovered/pressed are the contrast ratios of the highlight circle
+  // against the tab background.
+  constexpr float kMinimumActiveContrastRatio = 6.05f;
+  constexpr float kMinimumInactiveContrastRatio = 4.61f;
+  constexpr float kMinimumHoveredContrastRatio = 5.02f;
+  constexpr float kMinimumPressedContrastRatio = 4.41f;
+
+  // In some cases, inactive tabs may have background more like active tabs than
+  // inactive tabs, so colors should be adapted to ensure appropriate contrast.
+  // In particular, text should have plenty of contrast in all cases, so switch
+  // to using foreground color designed for active tabs if the tab looks more
+  // like an active tab than an inactive tab.
+  float expected_opacity = 0.0f;
+  if (tab_->IsActive()) {
+    expected_opacity = 1.0f;
+  } else if (tab_->IsSelected()) {
+    expected_opacity = kSelectedTabOpacity;
+  } else if (tab_->mouse_hovered()) {
+    expected_opacity = GetHoverOpacity();
+  }
+  const SkColor bg_color = color_utils::AlphaBlend(
+      tab_->controller()->GetTabBackgroundColor(TAB_ACTIVE),
+      tab_->controller()->GetTabBackgroundColor(TAB_INACTIVE),
+      expected_opacity);
+
+  SkColor title_color = tab_->controller()->GetTabForegroundColor(
+      expected_opacity > 0.5f ? TAB_ACTIVE : TAB_INACTIVE, bg_color);
+  title_color = color_utils::GetColorWithMinimumContrast(title_color, bg_color);
+
+  const SkColor base_hovered_color = theme_provider->GetColor(
+      ThemeProperties::COLOR_TAB_CLOSE_BUTTON_BACKGROUND_HOVER);
+  const SkColor base_pressed_color = theme_provider->GetColor(
+      ThemeProperties::COLOR_TAB_CLOSE_BUTTON_BACKGROUND_PRESSED);
+
+  const auto get_color_for_contrast_ratio = [](SkColor fg_color,
+                                               SkColor bg_color,
+                                               float contrast_ratio) {
+    const SkAlpha blend_alpha = color_utils::GetBlendValueWithMinimumContrast(
+        bg_color, fg_color, bg_color, contrast_ratio);
+    return color_utils::AlphaBlend(fg_color, bg_color, blend_alpha);
+  };
+
+  const SkColor generated_icon_color = get_color_for_contrast_ratio(
+      title_color, bg_color,
+      tab_->IsActive() ? kMinimumActiveContrastRatio
+                       : kMinimumInactiveContrastRatio);
+  const SkColor generated_hovered_color = get_color_for_contrast_ratio(
+      base_hovered_color, bg_color, kMinimumHoveredContrastRatio);
+  const SkColor generated_pressed_color = get_color_for_contrast_ratio(
+      base_pressed_color, bg_color, kMinimumPressedContrastRatio);
+
+  const SkColor generated_hovered_icon_color =
+      color_utils::GetColorWithMinimumContrast(title_color,
+                                               generated_hovered_color);
+  const SkColor generated_pressed_icon_color =
+      color_utils::GetColorWithMinimumContrast(title_color,
+                                               generated_pressed_color);
+
+  return {bg_color,
+          title_color,
+          generated_icon_color,
+          generated_hovered_icon_color,
+          generated_pressed_icon_color,
+          generated_hovered_color,
+          generated_pressed_color};
+}
+
+void EPTabStyle::PaintTab(gfx::Canvas* canvas, const SkPath& clip) const {
+  int active_tab_fill_id = 0;
+  int active_tab_y_inset = 0;
+  if (tab_->GetThemeProvider()->HasCustomImage(IDR_THEME_TOOLBAR)) {
+    active_tab_fill_id = IDR_THEME_TOOLBAR;
+    active_tab_y_inset = GetStrokeThickness(true);
+  }
+
+  if (tab_->IsActive()) {
+    PaintTabBackground(canvas, true /* active */, active_tab_fill_id,
+                       active_tab_y_inset, nullptr /* clip */);
+  } else {
+    PaintInactiveTabBackground(canvas, clip);
+
+    const float throb_value = GetThrobValue();
+    if (throb_value > 0) {
+      canvas->SaveLayerAlpha(gfx::ToRoundedInt(throb_value * 0xff),
+                             tab_->GetLocalBounds());
+      PaintTabBackground(canvas, true /* active */, active_tab_fill_id,
+                         active_tab_y_inset, nullptr /* clip */);
+      canvas->Restore();
+    }
+  }
+}
+
+void EPTabStyle::SetHoverLocation(const gfx::Point& location) {
+  if (hover_controller_)
+    hover_controller_->SetLocation(location);
+}
+
+void EPTabStyle::ShowHover(ShowHoverStyle style) {
+  if (!hover_controller_)
+    return;
+
+  if (style == ShowHoverStyle::kSubtle) {
+    hover_controller_->SetSubtleOpacityScale(
+        tab_->controller()->GetHoverOpacityForRadialHighlight());
+  }
+  hover_controller_->Show(style);
+}
+
+void EPTabStyle::HideHover(HideHoverStyle style) {
+  if (hover_controller_)
+    hover_controller_->Hide(style);
+}
+
+bool EPTabStyle::IsHoverActive() const {
+  if (!hover_controller_)
+    return false;
+  return hover_controller_->ShouldDraw();
+}
+
+double EPTabStyle::GetHoverAnimationValue() const {
+  if (!hover_controller_)
+    return 0.0;
+  return hover_controller_->GetAnimationValue();
+}
+
+float EPTabStyle::GetHoverOpacity() const {
+  // Opacity boost varies on tab width.  The interpolation is nonlinear so
+  // that most tabs will fall on the low end of the opacity range, but very
+  // narrow tabs will still stand out on the high end.
+  const float range_start = float{GetStandardWidth()};
+  const float range_end = float{GetMinimumInactiveWidth()};
+  const float value_in_range = float{tab_->width()};
+  const float t = (value_in_range - range_start) / (range_end - range_start);
+  return tab_->controller()->GetHoverOpacityForTab(t * t);
+}
+
+float EPTabStyle::GetThrobValue() const {
+  const bool is_selected = tab_->IsSelected();
+  double val = is_selected ? kSelectedTabOpacity : 0;
+
+  if (hover_controller_->ShouldDraw()) {
+    // Opacity boost varies on tab width.  The interpolation is nonlinear so
+    // that most tabs will fall on the low end of the opacity range, but very
+    // narrow tabs will still stand out on the high end.
+    const float range_start = float{GetStandardWidth()};
+    const float range_end = float{GetMinimumInactiveWidth()};
+    const float value_in_range = float{tab_->width()};
+    const float t = (value_in_range - range_start) / (range_end - range_start);
+    const float opacity = tab_->controller()->GetHoverOpacityForTab(t * t);
+    constexpr float kSelectedTabThrobScale = 0.95f - kSelectedTabOpacity;
+    val += hover_controller_->GetAnimationValue() *
+           (is_selected ? (kSelectedTabThrobScale * opacity) : opacity);
+  }
+  return val;
+}
+
+int EPTabStyle::GetStrokeThickness(bool should_paint_as_active) const {
+  return tab_->controller()->GetStrokeThickness();
+}
+
+void EPTabStyle::PaintInactiveTabBackground(gfx::Canvas* canvas,
+                                            const SkPath& clip) const {
+  bool has_custom_image;
+  int fill_id = tab_->controller()->GetBackgroundResourceId(&has_custom_image);
+  if (!has_custom_image)
+    fill_id = 0;
+
+  PaintTabBackground(canvas, false /* active */, fill_id, 0,
+                     tab_->controller()->MaySetClip() ? &clip : nullptr);
+}
+
+void EPTabStyle::PaintTabBackground(gfx::Canvas* canvas,
+                                    bool active,
+                                    int fill_id,
+                                    int y_inset,
+                                    const SkPath* clip) const {
+  // |y_inset| is only set when |fill_id| is being used.
+  DCHECK(!y_inset || fill_id);
+
+  const SkColor active_color =
+      tab_->controller()->GetTabBackgroundColor(TAB_ACTIVE);
+  // TODO
+  const SkColor inactive_color =
+      tab_->GetThemeProvider()->GetDisplayProperty(
+          ThemeProperties::SHOULD_FILL_BACKGROUND_TAB_COLOR)
+          ? tab_->controller()->GetTabBackgroundColor(TAB_INACTIVE)
+          : SK_ColorTRANSPARENT;
+  const SkColor stroke_color =
+      tab_->controller()->GetToolbarTopSeparatorColor();
+  const bool paint_hover_effect = !active && IsHoverActive();
+  const float scale = canvas->image_scale();
+  const float stroke_thickness = GetStrokeThickness(active);
+
+  if (fill_id || paint_hover_effect) {
+    SkPath fill_path = GetPath(PathType::kInteriorClip,scale,active);
+    PaintTabBackgroundFill(canvas, fill_path, active, paint_hover_effect,
+                           active_color, inactive_color, fill_id, y_inset);
+    if (stroke_thickness > 0) {
+      SkPath stroke_path = GetPath(PathType::kBorder, scale, active);
+      gfx::ScopedCanvas scoped_canvas(clip ? canvas : nullptr);
+      if (clip)
+        canvas->sk_canvas()->clipPath(*clip, SkClipOp::kDifference, true);
+      PaintTabBackgroundStroke(canvas, fill_path, stroke_path, active,
+                               stroke_color);
+    }
+  } else {
+    const gfx::Size& size = tab_->size();
+    BackgroundCache& cache =
+        active ? background_active_cache_ : background_inactive_cache_;
+    if (cache.UpdateCacheKey(scale, size, active_color, inactive_color,
+                             stroke_color, stroke_thickness)) {
+      SkPath fill_path = GetPath(PathType::kInteriorClip, scale, active);
+      SkPath stroke_path = GetPath(PathType::kBorder, scale, active);
+      cc::PaintRecorder recorder;
+
+      {
+        gfx::Canvas cache_canvas(
+            recorder.beginRecording(size.width(), size.height()), scale);
+        PaintTabBackgroundFill(&cache_canvas, fill_path, active,
+                               paint_hover_effect, active_color, inactive_color,
+                               fill_id, y_inset);
+        cache.set_fill_record(recorder.finishRecordingAsPicture());
+      }
+      if (stroke_thickness > 0) {
+        gfx::Canvas cache_canvas(
+            recorder.beginRecording(size.width(), size.height()), scale);
+        PaintTabBackgroundStroke(&cache_canvas, fill_path, stroke_path, active,
+                                 stroke_color);
+        cache.set_stroke_record(recorder.finishRecordingAsPicture());
+      }
+    }
+
+    canvas->sk_canvas()->drawPicture(cache.fill_record());
+    if (stroke_thickness > 0) {
+      gfx::ScopedCanvas scoped_canvas(clip ? canvas : nullptr);
+      if (clip)
+        canvas->sk_canvas()->clipPath(*clip, SkClipOp::kDifference, true);
+      canvas->sk_canvas()->drawPicture(cache.stroke_record());
+    }
+  }
+}
+
+void EPTabStyle::PaintTabBackgroundFill(gfx::Canvas* canvas,
+                                        const SkPath& fill_path,
+                                        bool active,
+                                        bool paint_hover_effect,
+                                        SkColor active_color,
+                                        SkColor inactive_color,
+                                        int fill_id,
+                                        int y_inset) const {
+  gfx::ScopedCanvas scoped_canvas(canvas);
+  const float scale = canvas->UndoDeviceScaleFactor();
+
+  canvas->ClipPath(fill_path, true);
+  if (fill_id) {
+    gfx::ScopedCanvas scale_scoper(canvas);
+    canvas->sk_canvas()->scale(scale, scale);
+    canvas->TileImageInt(*tab_->GetThemeProvider()->GetImageSkiaNamed(fill_id),
+                         tab_->GetMirroredX() + tab_->background_offset(), 0, 0,
+                         y_inset, tab_->width(), tab_->height());
+  } else {
+    cc::PaintFlags flags;
+    flags.setAntiAlias(true);
+    flags.setColor(active ? active_color : inactive_color);
+    canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),
+                     flags);
+  }
+
+  if (paint_hover_effect) {
+    SkPoint hover_location(gfx::PointToSkPoint(hover_controller_->location()));
+    hover_location.scale(SkFloatToScalar(scale));
+    const SkScalar kMinHoverRadius = 16;
+    const SkScalar radius =
+        std::max(SkFloatToScalar(tab_->width() / 4.f), kMinHoverRadius);
+    DrawHighlight(canvas, hover_location, radius * scale,
+                  SkColorSetA(active_color, hover_controller_->GetAlpha()));
+  }
+}
+
+void EPTabStyle::PaintTabBackgroundStroke(gfx::Canvas* canvas,
+                                          const SkPath& fill_path,
+                                          const SkPath& stroke_path,
+                                          bool active,
+                                          SkColor stroke_color) const {
+  gfx::ScopedCanvas scoped_canvas(canvas);
+  const float scale = canvas->UndoDeviceScaleFactor();
+
+  if (!active) {
+    // Clip out the bottom line; this will be drawn for us by
+    // TabStrip::PaintChildren().
+    canvas->ClipRect(
+        gfx::RectF(tab_->width() * scale, tab_->height() * scale - 1));
+  }
+  cc::PaintFlags flags;
+  flags.setAntiAlias(true);
+  flags.setColor(stroke_color);
+  SkPath path;
+  Op(stroke_path, fill_path, kDifference_SkPathOp, &path);
+  canvas->DrawPath(path, flags);
+}
+
+// static
+float EPTabStyle::GetTopCornerRadiusForWidth(int width) {
+  // Get the width of the top of the tab by subtracting the width of the outer
+  // corners.
+  const int ideal_radius = GetCornerRadius();
+  const int top_width = width - ideal_radius * 2;
+
+  // To maintain a round-rect appearance, ensure at least one third of the top
+  // of the tab is flat.
+  const float radius = top_width / 3.f;
+  return base::ClampToRange<float>(radius, 0, ideal_radius);
+}
+
+}  // namespace eye_protection
diff --git a/chrome/browser/ui/views/tabs/tab_style_views.cc b/chrome/browser/ui/views/tabs/tab_style_views.cc
index 464249bcc81e..28ddad16a7d3 100644
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -24,6 +24,11 @@
 #include "ui/views/style/platform_style.h"
 #include "ui/views/widget/widget.h"
 
+#include "ui/base/material_design/material_design_controller.h"
+#include "chrome/browser/ui/views/tabs/tab_style_ep.cc"
+
+using MD = ui::MaterialDesignController;
+
 namespace {
 
 // Opacity of the active tab background painted over inactive selected tabs.
@@ -819,6 +824,8 @@ TabStyleViews::~TabStyleViews() = default;
 
 // static
 std::unique_ptr<TabStyleViews> TabStyleViews::CreateForTab(Tab* tab) {
+  if (MD::eye_protection())
+    return std::make_unique<eye_protection::EPTabStyle>(tab);
   return std::make_unique<GM2TabStyle>(tab);
 }
 
@@ -829,6 +836,8 @@ int TabStyleViews::GetMinimumActiveWidth() {
 
 // static
 int TabStyleViews::GetMinimumInactiveWidth() {
+  if (MD::eye_protection())
+    return GetContentsHorizontalInsetSize();
   // Allow tabs to shrink until they appear to be 16 DIP wide excluding
   // outer corners.
   constexpr int kInteriorWidth = 16;
-- 
2.18.0.windows.1

